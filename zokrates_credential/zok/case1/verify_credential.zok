import "hashes/sha256/512bitPacked" as sha256packed;
import "signatures/verifyEddsa" as verifyEddsa;

struct BabyJubJubParams {
	field JUBJUB_C;
	field JUBJUB_A;
	field JUBJUB_D;
	field MONT_A;
	field MONT_B;
	field[2] INFINITY;
	field Gu;
	field Gv;
}

const BabyJubJubParams BABYJUBJUB_PARAMS = BabyJubJubParams {
    // Order of the curve for reference: 21888242871839275222246405745257275088614511777268538073601725287587578984328
    JUBJUB_C: 8, // Cofactor
    JUBJUB_A: 168700, // Coefficient A
    JUBJUB_D: 168696, // Coefficient D

    // Montgomery parameters
    MONT_A: 168698,
    MONT_B: 1,

    // Point at infinity
    INFINITY: [0, 1],

    // Generator
    Gu: 16540640123574156134436876038791482806971768689494387082833631921987005038935,
    Gv: 20819045374670962167435360035096875258406992893633759881276124905556507972311
};



def main(private field context_hash, private field id_hash, private field credential_type_hash, private field issuer_hash, private field credential_subject_hash, private field alumni_of_hash, private field age, private field exp, private field[2] R, private field S) {
    // 첫 번째 4개 입력에 대한 해시 계산
    field[2] first_hash = sha256packed([context_hash, id_hash, credential_type_hash, issuer_hash]);
    
    // 두 번째 4개 입력에 대한 해시 계산
    field[2] second_hash = sha256packed([credential_subject_hash, alumni_of_hash, age, exp]);
    
    // 첫 번째 및 두 번째 해시 결과를 다시 해시하여 최종 해시를 계산
    field[2] final_hash = sha256packed([first_hash[0], first_hash[1], second_hash[0], second_hash[1]]);

    // Eddsa 서명 검증
    // 서명 :(R, S), 공개키 : A, Memo : [final_hash[0], final_hash[1]]
    field[2] A = [123456789, 123456789];
    bool signature_valid = verifyEddsa(R, S, A, [final_hash[0], final_hash[1]], BABYJUBJUB_PARAMS);
    assert(signature_valid == true);

     // 나이가 20살 이상인지 검사
    assert(age >= 20);

    return;
}